{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","Display/Buttons.js","Display/Home.js","Display/Info.js","Display/Statistics.js","Algorithms/dijkstra.js","Algorithms/bfs.js","Algorithms/dfs.js","Algorithms/Astar.js","PathfindingVisualizer/PathfindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isEnd","isStart","isWall","weight","onMouseDown","onMouseEnter","onMouseUp","row","newlassName","symbol","id","className","Component","Buttons","ans","brick","onChange","event","algo","target","value","callback5","onClick","callback1","callback2","callback3","callback4","Home","callback7","text","Info","Statistics","time","length","shortLength","pathLength","dijkstra","grid","startNode","finishNode","diagonal","visitedNodes","unvisitedNodes","nodes","node","isVisited","parent","distance","Infinity","push","getAllNodes","sortNodesByDistance","closestNode","shift","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","x","bfs","dfs","pop","Astar","f","g","h","closed","openHeap","Heap","size","currNeighbors","i","neighbour","previousNode","gScore","beenVisited","manhattan","remove","pos0","pos1","Math","abs","startRow","startCol","endRow","endCol","startTime","endTime","delta","PathfindingVisualizer","state","initialGrid","isMousePressed","path","short","canChange","wall","addWeight","addWall","prevWeight","initialWallState","finalPos","endPoint","last","immutable","callRemoveAnimation","homeProp","selectedAlgo","endpointmove","diagonalMovement","visualizationTime","setState","Date","newGrid","toggleGrid","slice","newNode","n","document","getElementById","shortestPathNodes","setTimeout","addAnimationToShortestPath","isMutable","defaultGrid","RemoveAnimation","mousePressed","change","pat","currWeight","nodePrev","newnodePrev","floor","random","removeAnimation","curr","reverse","nodesInShortestPath","nodesInShortestPathbfs","nodesInShortestPathdfs","nodesInShortestPathastar","addAnimationToAlgorithm","alert","inputAlgo","noChange","visualizeAlgorithm","changeWeight","clearpath","changediagonal","oo","chooseAlg","onMouseLeave","removeMouseDown","map","rowIndex","key","nodeIndex","mouseDownHandler","mouseEnterHandler","mouseUpHandler","currentRow","createNode","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.ee411aac.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isEnd,\r\n      isStart,\r\n      isWall,\r\n      weight,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const newlassName = isEnd\r\n      ? \"node-end\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n    const symbol = weight > 0 ? \"dot\" : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${newlassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      >\r\n        <span className={`circle ${symbol}`}></span>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport \"./Buttons.css\";\r\nfunction Buttons(props) {\r\n  const assignAlgo = (algo) => {\r\n    props.callback5(algo);\r\n  };\r\n  const ans = props.brick ? \"Weight\" : \"Wall\";\r\n  return (\r\n    <div className=\"disp\">\r\n      <h2 className=\"para\">Select Algorithm :</h2>\r\n      <select\r\n        className=\"algos\"\r\n        onChange={(event) => assignAlgo(event.target.value)}\r\n      >\r\n        <option className=\"internal\">Dijkstra Algorithm</option>\r\n        <option className=\"internal\">BFS Algorithm</option>\r\n        <option className=\"internal\">DFS Algorithm</option>\r\n        <option className=\"internal\">A &#9734; Algorithm</option>\r\n      </select>\r\n      <button className=\"ll\" onClick={() => props.callback1()}>\r\n        Visualize\r\n      </button>\r\n      <button className=\"ll\" onClick={() => props.callback2()}>\r\n        {ans}\r\n      </button>\r\n      <button className=\"lol\" onClick={() => props.callback3()}>\r\n        Clear Board\r\n      </button>\r\n\r\n      <button className=\"lol\" onClick={() => props.callback4()}>\r\n        {props.value}\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Buttons;\r\n","import React from \"react\";\r\nimport \"./Home.css\";\r\nfunction Home(props) {\r\n  return (\r\n    <>\r\n      <div className=\"home\">\r\n        <h1 className=\"headingHome\">Pathfinding Visualizer</h1>\r\n        <h3 className=\"help\" onClick={() => props.callback7()}>\r\n          {props.text}\r\n        </h3>\r\n      </div>\r\n      <div className=\"reveal\" id=\"show\">\r\n        <p className=\"heading\">Instructions</p>\r\n        <p className=\"leftAlign\">\r\n          Select an Algorithm to visualize from the dropdown menu.\r\n        </p>\r\n        <p className=\"leftAlign\">\r\n          To add wall or weight by click the corresponding Button.\r\n        </p>\r\n        <p className=\"leftAlign\">To add wall/weight to a cell single click.</p>\r\n        <p className=\"leftAlign\">\r\n          To add multiple wall/weight simaltaneously :-\r\n        </p>\r\n        <p className=\"leftAlign\">\r\n          I. Click on a empty cell and hold for a sec, then move over the cells\r\n          to add wall/weight.\r\n        </p>\r\n        <p className=\"leftAlign\">\r\n          II. When done click on a cell or move out of the grid to stop adding\r\n          wall/weight\r\n        </p>\r\n        <p className=\"leftAlign\">\r\n          To clear the wall/weight repeat the above steps on node having\r\n          wall/weight.\r\n        </p>\r\n        <p className=\"leftAlign\">\r\n          To clear the board click Clear Board Button.\r\n        </p>\r\n        <p className=\"leftAlign\">Control diagonal movement through checkbox.</p>\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Home;\r\n","import React from \"react\";\r\nimport \"./Info.css\";\r\nfunction Info() {\r\n  return (\r\n    <div className=\"information\">\r\n      <div>\r\n        <div className=\"nodeinfo\">Start Node</div>\r\n        <div className=\"startbox\"> </div>\r\n      </div>\r\n      <div>\r\n        <div className=\"nodeinfo\">End Node</div>\r\n        <div className=\"endbox\"></div>\r\n      </div>\r\n      <div>\r\n        <div className=\"nodeinfo\">Wall</div>\r\n        <div className=\"wallbox\"></div>\r\n      </div>\r\n      <div>\r\n        <div className=\"nodeinfo\">Weight</div>\r\n        <div className=\"weightbox\"></div>\r\n      </div>\r\n      <div>\r\n        <div className=\"nodeinfo\">Visited Node</div>\r\n        <div className=\"visitedbox\"> </div>\r\n      </div>\r\n      <div>\r\n        <div className=\"nodeinfo\">ShortestPath</div>\r\n        <div className=\"shortestbox\"></div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Info;\r\n","import React from \"react\";\r\nimport \"./Statistics.css\";\r\nfunction Statistics(props) {\r\n  const text =\r\n    props.text === \"Dijkstra Algorithm\"\r\n      ? \"Dijkstra's algorithm is commonly used for calculating shortest path.\"\r\n      : props.text === \"BFS Algorithm\"\r\n      ? \"BFS algorithm will give shortest path only when weight of each node is zero.\"\r\n      : props.text === \"DFS Algorithm\"\r\n      ? \"DFS Algorithm does not guarantee shortest path.\"\r\n      : \" A* is a faster and more efficient version of Dijkstra’s algorithm.\";\r\n  const time = props.time / 1000;\r\n  const length = props.shortLength;\r\n\r\n  return (\r\n    <div className=\"info\">\r\n      <p className=\"insideinfo\"> {text}</p>\r\n      {length > 1 ? (\r\n        <div>\r\n          <p className=\"stats\">\r\n            Nodes Visited : {props.pathLength} , Nodes in Shortest Path :\r\n            {props.shortLength} , Visualization Time : {time}s\r\n          </p>\r\n        </div>\r\n      ) : (\r\n        <p></p>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Statistics;\r\n","export function dijkstra(grid, startNode, finishNode, diagonal) {\r\n  const visitedNodes = [];\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  startNode.distance = 0;\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    } else {\r\n      if (closestNode.distance === Infinity) return visitedNodes;\r\n      closestNode.isVisited = true;\r\n      visitedNodes.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodes;\r\n      updateUnvisitedNeighbors(closestNode, grid, diagonal);\r\n    }\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, diagonal) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, diagonal);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    let x = node.distance + 1 + neighbor.weight;\r\n    if (neighbor.distance > x) {\r\n      neighbor.distance = x;\r\n      neighbor.parent = node;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid, diagonal) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (diagonal) {\r\n    if (row > 0 && col > 0) neighbors.push(grid[row - 1][col - 1]);\r\n    if (row < grid.length - 1 && col < grid[0].length - 1)\r\n      neighbors.push(grid[row + 1][col + 1]);\r\n    if (col > 0 && row < grid.length - 1)\r\n      neighbors.push(grid[row + 1][col - 1]);\r\n    if (row > 0 && col < grid[0].length - 1)\r\n      neighbors.push(grid[row - 1][col + 1]);\r\n  }\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      node.isVisited = false;\r\n      node.parent = null;\r\n      node.distance = Infinity;\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function nodesInShortestPath(finishNode) {\r\n  var curr = finishNode;\r\n  var shortestPathNodes = [];\r\n  while (curr.parent) {\r\n    shortestPathNodes.push(curr);\r\n    curr = curr.parent;\r\n  }\r\n  shortestPathNodes.push(curr);\r\n  return shortestPathNodes.reverse();\r\n}\r\n","export function bfs(grid, startNode, finishNode, diagonal) {\r\n  getAllNodes(grid);\r\n  const visitedNodes = [];\r\n  const unvisitedNodes = [];\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n  while (!!unvisitedNodes.length) {\r\n    const closestNode = unvisitedNodes.shift();\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    } else {\r\n      if (closestNode.distance === Infinity) return visitedNodes;\r\n      closestNode.isVisited = true;\r\n      visitedNodes.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodes;\r\n      updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes, diagonal);\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes, diagonal) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, diagonal);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.parent = node;\r\n    if (neighbor.isVisited === false) {\r\n      unvisitedNodes.push(neighbor);\r\n      neighbor.isVisited = true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid, diagonal) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (diagonal) {\r\n    if (row > 0 && col > 0) neighbors.push(grid[row - 1][col - 1]);\r\n    if (row < grid.length - 1 && col < grid[0].length - 1)\r\n      neighbors.push(grid[row + 1][col + 1]);\r\n    if (col > 0 && row < grid.length - 1)\r\n      neighbors.push(grid[row + 1][col - 1]);\r\n    if (row > 0 && col < grid[0].length - 1)\r\n      neighbors.push(grid[row - 1][col + 1]);\r\n  }\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      node.isVisited = false;\r\n      node.parent = null;\r\n      node.distance = Infinity;\r\n      node.weight = 0;\r\n    }\r\n  }\r\n}\r\n\r\nexport function nodesInShortestPathbfs(finishNode) {\r\n  var curr = finishNode;\r\n  var shortestPathNodes = [];\r\n  while (curr.parent) {\r\n    shortestPathNodes.push(curr);\r\n    curr = curr.parent;\r\n  }\r\n  shortestPathNodes.push(curr);\r\n  return shortestPathNodes.reverse();\r\n}\r\n","export function dfs(grid, startNode, finishNode, diagonal) {\r\n  getAllNodes(grid);\r\n  const visitedNodes = [];\r\n  const unvisitedNodes = [];\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n  while (!!unvisitedNodes.length) {\r\n    const closestNode = unvisitedNodes.pop();\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    } else {\r\n      if (closestNode.distance === Infinity) return visitedNodes;\r\n      closestNode.isVisited = true;\r\n      visitedNodes.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodes;\r\n      updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes, diagonal);\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes, diagonal) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, diagonal);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.parent = node;\r\n    if (neighbor.isVisited === false) {\r\n      unvisitedNodes.push(neighbor);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid, diagonal) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (diagonal) {\r\n    if (row > 0 && col > 0) neighbors.push(grid[row - 1][col - 1]);\r\n    if (row < grid.length - 1 && col < grid[0].length - 1)\r\n      neighbors.push(grid[row + 1][col + 1]);\r\n    if (col > 0 && row < grid.length - 1)\r\n      neighbors.push(grid[row + 1][col - 1]);\r\n    if (row > 0 && col < grid[0].length - 1)\r\n      neighbors.push(grid[row - 1][col + 1]);\r\n  }\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      node.isVisited = false;\r\n      node.parent = null;\r\n      node.distance = Infinity;\r\n      node.weight = 0;\r\n    }\r\n  }\r\n}\r\n\r\nexport function nodesInShortestPathdfs(finishNode) {\r\n  var curr = finishNode;\r\n  var shortestPathNodes = [];\r\n  while (curr.parent) {\r\n    shortestPathNodes.push(curr);\r\n    curr = curr.parent;\r\n  }\r\n  shortestPathNodes.push(curr);\r\n  return shortestPathNodes.reverse();\r\n}\r\n","import Heap from \"heap-js\";\r\nexport function Astar(grid, startNode, finishNode, diagonal) {\r\n  getAllNodes(grid);\r\n  const visitedNodes = [];\r\n  var openHeap = new Heap(function (nodeA, nodeB) {\r\n    if (nodeA.f !== nodeB.f) {\r\n      return nodeA.f - nodeB.f;\r\n    }\r\n    return nodeB.g - nodeA.g;\r\n  });\r\n  startNode.distance = 0;\r\n  openHeap.push(startNode);\r\n\r\n  while (openHeap.size() > 0) {\r\n    var closestNode = openHeap.pop();\r\n    visitedNodes.push(closestNode);\r\n    closestNode.closed = true;\r\n    if (closestNode === finishNode) return visitedNodes;\r\n    var currNeighbors = getUnvisitedNeighbors(closestNode, grid, diagonal);\r\n    for (var i = 0; i < currNeighbors.length; i++) {\r\n      var neighbour = currNeighbors[i];\r\n      var previousNode = neighbour;\r\n      if (neighbour.closed || neighbour.isWall) {\r\n        continue;\r\n      } else {\r\n        var gScore = closestNode.g + 1 + neighbour.weight;\r\n        var beenVisited = neighbour.isVisited;\r\n        if (!beenVisited || gScore < neighbour.g) {\r\n          neighbour.isVisited = true;\r\n          neighbour.parent = closestNode;\r\n          neighbour.h = neighbour.h || manhattan(neighbour, finishNode);\r\n          neighbour.g = gScore;\r\n          neighbour.f = neighbour.g + neighbour.h;\r\n          if (!beenVisited) {\r\n            openHeap.push(neighbour);\r\n          } else {\r\n            openHeap.remove(previousNode);\r\n            openHeap.push(neighbour);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction manhattan(pos0, pos1) {\r\n  var d1 = Math.abs(pos1.row - pos0.row);\r\n  var d2 = Math.abs(pos1.col - pos0.col);\r\n  return d1 + d2;\r\n}\r\nfunction getUnvisitedNeighbors(node, grid, diagonal) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (diagonal) {\r\n    if (row > 0 && col > 0) neighbors.push(grid[row - 1][col - 1]);\r\n    if (row < grid.length - 1 && col < grid[0].length - 1)\r\n      neighbors.push(grid[row + 1][col + 1]);\r\n    if (col > 0 && row < grid.length - 1)\r\n      neighbors.push(grid[row + 1][col - 1]);\r\n    if (row > 0 && col < grid[0].length - 1)\r\n      neighbors.push(grid[row - 1][col + 1]);\r\n  }\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n\r\n  return neighbors;\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      node.isVisited = false;\r\n      node.parent = null;\r\n      node.distance = Infinity;\r\n      node.f = 0;\r\n      node.g = 0;\r\n      node.h = 0;\r\n      node.closed = false;\r\n    }\r\n  }\r\n}\r\n\r\nexport function nodesInShortestPathastar(finishNode) {\r\n  var curr = finishNode;\r\n  var shortestPathNodes = [];\r\n  while (curr.parent) {\r\n    shortestPathNodes.push(curr);\r\n    curr = curr.parent;\r\n  }\r\n  shortestPathNodes.push(curr);\r\n  return shortestPathNodes.reverse();\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport Buttons from \".././Display/Buttons\";\r\nimport Home from \".././Display/Home\";\r\nimport Info from \".././Display/Info\";\r\nimport Statistics from \".././Display/Statistics\";\r\nimport { dijkstra, nodesInShortestPath } from \"../Algorithms/dijkstra\";\r\nimport { bfs, nodesInShortestPathbfs } from \"../Algorithms/bfs\";\r\nimport { dfs, nodesInShortestPathdfs } from \"../Algorithms/dfs\";\r\nimport { Astar, nodesInShortestPathastar } from \"../Algorithms/Astar\";\r\nimport \"./PathfindingVisualizer.css\";\r\nvar startRow = 2;\r\nvar startCol = 2;\r\nvar endRow = 17;\r\nvar endCol = 37;\r\nvar startTime = 0;\r\nvar endTime = 0;\r\nvar delta = 0;\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: initialGrid(),\r\n      isMousePressed: false,\r\n      path: [],\r\n      short: [],\r\n      canChange: true,\r\n      wall: true,\r\n      addWeight: true,\r\n      addWall: true,\r\n      prevWeight: false,\r\n      initialWallState: true,\r\n      finalPos: false,\r\n      endPoint: false,\r\n      last: false,\r\n      immutable: false,\r\n      callRemoveAnimation: false,\r\n      homeProp: \"Instructions\",\r\n      selectedAlgo: \"Dijkstra Algorithm\",\r\n      endpointmove: true,\r\n      diagonalMovement: false,\r\n      visualizationTime: 0,\r\n    };\r\n  }\r\n  mouseDownHandler(row, col) {\r\n    if (this.state.immutable) {\r\n      return;\r\n    }\r\n    this.setState({ isMousePressed: false });\r\n\r\n    startTime = new Date();\r\n    if (delta > 0.25) {\r\n      const newGrid = this.toggleGrid(\r\n        this.state.grid,\r\n        row,\r\n        col,\r\n        true,\r\n        this.state.canChange,\r\n        this.state.path\r\n      );\r\n      this.setState({ grid: newGrid });\r\n    } else {\r\n      const newGrid = this.toggleGrid(\r\n        this.state.grid,\r\n        row,\r\n        col,\r\n        false,\r\n        this.state.canChange,\r\n        this.state.path\r\n      );\r\n      this.setState({ grid: newGrid });\r\n    }\r\n  }\r\n\r\n  mouseEnterHandler(row, col) {\r\n    if (this.state.immutable) {\r\n      return;\r\n    }\r\n\r\n    if (delta < 0.25) {\r\n      this.setState({ endPoint: false });\r\n      this.setState({ endpointmove: true });\r\n      this.setState({ last: false });\r\n      this.setState({ prevWeight: false });\r\n      return;\r\n    }\r\n\r\n    this.setState({ isMousePressed: true });\r\n\r\n    const newGrid = this.toggleGrid(\r\n      this.state.grid,\r\n      row,\r\n      col,\r\n      true,\r\n      this.state.canChange,\r\n      this.state.path\r\n    );\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  mouseUpHandler() {\r\n    if (this.state.immutable) {\r\n      return;\r\n    }\r\n    endTime = new Date();\r\n\r\n    delta = (endTime - startTime) / 1000.0;\r\n    if (delta < 0.25) {\r\n      this.setState({ endPoint: false });\r\n      this.setState({ endpointmove: true });\r\n      this.setState({ last: false });\r\n      this.setState({ prevWeight: false });\r\n    }\r\n    let newGrid = this.state.grid.slice();\r\n    let node = newGrid[endRow][endCol];\r\n    let newNode = {\r\n      ...node,\r\n      isWall: false,\r\n      weight: 0,\r\n    };\r\n    newGrid[endRow][endCol] = newNode;\r\n    node = newGrid[startRow][startCol];\r\n    newNode = {\r\n      ...node,\r\n      isWall: false,\r\n      weight: 0,\r\n    };\r\n    newGrid[startRow][startCol] = newNode;\r\n    this.setState({ grid: newGrid });\r\n  }\r\n  RemoveAnimation() {\r\n    const { grid } = this.state;\r\n    for (let i = 0; i < this.state.path.length; i++) {\r\n      const node = this.state.path[i];\r\n      const n = grid[node.row][node.col];\r\n\r\n      if (!n.isWall && !n.isEnd && !n.isStart) {\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node\";\r\n      }\r\n    }\r\n  }\r\n\r\n  addAnimationToAlgorithm(visitedNodes, shortestPathNodes) {\r\n    this.setState({\r\n      canChange: false,\r\n    });\r\n\r\n    for (let i = 0; i <= visitedNodes.length; i++) {\r\n      if (i === visitedNodes.length) {\r\n        setTimeout(() => {\r\n          this.addAnimationToShortestPath(shortestPathNodes);\r\n        }, 10 * i);\r\n      } else {\r\n        const node = visitedNodes[i];\r\n\r\n        if (\r\n          !(\r\n            (node.col === endCol && node.row === endRow) ||\r\n            (node.col === startCol && node.row === startRow)\r\n          )\r\n        ) {\r\n          setTimeout(() => {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-visited\";\r\n          }, 10 * i);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  addAnimationToShortestPath(shortestPathNodes) {\r\n    this.setState({\r\n      canChange: false,\r\n    });\r\n\r\n    for (let i = 0; i < shortestPathNodes.length; i++) {\r\n      const node = shortestPathNodes[i];\r\n\r\n      if (\r\n        !(\r\n          (node.col === endCol && node.row === endRow) ||\r\n          (node.col === startCol && node.row === startRow)\r\n        )\r\n      ) {\r\n        setTimeout(() => {\r\n          this.setState({\r\n            canChange: false,\r\n          });\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortestpath\";\r\n        }, 70 * i);\r\n      }\r\n    }\r\n  }\r\n  noChange() {\r\n    const isMutable = !this.state.immutable;\r\n    if (isMutable) {\r\n      document.getElementById(`show`).className = \"  hide\";\r\n      this.setState({ homeProp: \"Close\" });\r\n    } else {\r\n      document.getElementById(`show`).className = \"  reveal\";\r\n      this.setState({ homeProp: \"Instructions\" });\r\n    }\r\n    this.setState({ immutable: isMutable });\r\n  }\r\n  changediagonal() {\r\n    const diagonal = !this.state.diagonalMovement;\r\n    this.setState({ diagonalMovement: diagonal });\r\n  }\r\n  removeMouseDown() {\r\n    delta = 0;\r\n  }\r\n  clearpath() {\r\n    const { canChange } = this.state;\r\n    if (!canChange) {\r\n      return;\r\n    }\r\n\r\n    const defaultGrid = initialGrid();\r\n\r\n    if (this.state.path.length) {\r\n      this.RemoveAnimation();\r\n    }\r\n    this.setState({ grid: defaultGrid });\r\n    this.setState({ short: [] });\r\n    this.setState({ path: [] });\r\n  }\r\n  toggleGrid(grid, row, col, mousePressed, change, pat) {\r\n    var newGrid = grid.slice();\r\n    var node = newGrid[row][col];\r\n    var currWeight = 0;\r\n\r\n    if (!change) {\r\n      return newGrid;\r\n    }\r\n    if (this.state.endpointmove && this.state.endPoint) {\r\n      if (this.state.path.length) {\r\n        this.RemoveAnimation();\r\n        this.setState({ short: [] });\r\n        this.setState({ path: [] });\r\n      }\r\n      if (this.state.last) {\r\n        const newNode = {\r\n          ...node,\r\n          isEnd: !node.isEnd,\r\n          isVisited: true,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        const nodePrev = newGrid[endRow][endCol];\r\n        const newnodePrev = {\r\n          ...nodePrev,\r\n          isEnd: !nodePrev.isEnd,\r\n        };\r\n        newGrid[endRow][endCol] = newnodePrev;\r\n        endRow = row;\r\n        endCol = col;\r\n        return newGrid;\r\n      } else {\r\n        const newNode = {\r\n          ...node,\r\n          isStart: !node.isStart,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        const nodePrev = newGrid[startRow][startCol];\r\n        const newnodePrev = {\r\n          ...nodePrev,\r\n          isStart: !nodePrev.isStart,\r\n        };\r\n        newGrid[startRow][startCol] = newnodePrev;\r\n        startRow = row;\r\n        startCol = col;\r\n        return newGrid;\r\n      }\r\n    } else {\r\n      if (node.col === startCol && node.row === startRow) {\r\n        this.setState({ endPoint: true });\r\n        return newGrid;\r\n      }\r\n\r\n      if (node.col === endCol && node.row === endRow) {\r\n        this.setState({ endPoint: true });\r\n        this.setState({ last: true });\r\n        return newGrid;\r\n      } else {\r\n        this.setState({ endpointmove: false });\r\n\r\n        if (this.state.path.length) {\r\n          this.RemoveAnimation();\r\n          this.setState({ short: [] });\r\n          this.setState({ path: [] });\r\n        }\r\n\r\n        if (!mousePressed) {\r\n          if (this.state.wall) {\r\n            const newNode = {\r\n              ...node,\r\n              isWall: !node.isWall,\r\n              weight: 0,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n\r\n            this.setState({ initialWallState: newNode.isWall });\r\n\r\n            return newGrid;\r\n          } else {\r\n            currWeight = node.weight;\r\n\r\n            if (currWeight) {\r\n              currWeight = 0;\r\n              this.setState({ prevWeight: false });\r\n            } else {\r\n              currWeight = Math.floor(Math.random() * 10) + 5;\r\n              this.setState({ prevWeight: true });\r\n            }\r\n            const newNode = {\r\n              ...node,\r\n              weight: currWeight,\r\n              isWall: false,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n\r\n            return newGrid;\r\n          }\r\n        } else {\r\n          if (this.state.wall) {\r\n            const newNode = {\r\n              ...node,\r\n              isWall: this.state.initialWallState,\r\n              weight: 0,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            return newGrid;\r\n          } else {\r\n            currWeight = 0;\r\n            if (this.state.prevWeight) {\r\n              currWeight = Math.floor(Math.random() * 10) + 5;\r\n            }\r\n            const newNode = {\r\n              ...node,\r\n              weight: currWeight,\r\n              isWall: false,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            return newGrid;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  visualizeAlgorithm() {\r\n    const { canChange, immutable, removeAnimation } = this.state;\r\n\r\n    if (!canChange || immutable) {\r\n      return;\r\n    }\r\n\r\n    if (removeAnimation) {\r\n      this.RemoveAnimation();\r\n    }\r\n    const { grid } = this.state;\r\n    const { diagonalMovement } = this.state;\r\n\r\n    let dv, ds, time;\r\n    const startNode = grid[startRow][startCol];\r\n    const finishNode = grid[endRow][endCol];\r\n    var visitedNodes = {};\r\n    var shortestPathNodes = {};\r\n    if (this.state.selectedAlgo === \"Dijkstra Algorithm\") {\r\n      visitedNodes = dijkstra(grid, startNode, finishNode, diagonalMovement);\r\n      shortestPathNodes = nodesInShortestPath(finishNode);\r\n    } else if (this.state.selectedAlgo === \"BFS Algorithm\") {\r\n      visitedNodes = bfs(grid, startNode, finishNode, diagonalMovement);\r\n      shortestPathNodes = nodesInShortestPathbfs(finishNode);\r\n    } else if (this.state.selectedAlgo === \"DFS Algorithm\") {\r\n      visitedNodes = dfs(grid, startNode, finishNode, diagonalMovement);\r\n      shortestPathNodes = nodesInShortestPathdfs(finishNode);\r\n    } else {\r\n      visitedNodes = Astar(grid, startNode, finishNode, diagonalMovement);\r\n      shortestPathNodes = nodesInShortestPathastar(finishNode);\r\n    }\r\n\r\n    if (grid[endRow][endCol].isVisited) {\r\n      dv = visitedNodes.length;\r\n      ds = shortestPathNodes.length;\r\n      time = (dv + 1) * 10 + ds * 70 + 250;\r\n      this.setState({ visualizationTime: time });\r\n\r\n      this.setState({ path: visitedNodes });\r\n      this.setState({ short: shortestPathNodes });\r\n\r\n      this.addAnimationToAlgorithm(visitedNodes, shortestPathNodes);\r\n      setTimeout(() => {\r\n        this.setState({\r\n          canChange: true,\r\n        });\r\n      }, time);\r\n\r\n      this.setState({ removeAnimation: true });\r\n    } else {\r\n      alert(\"NO PATH EXISTS\");\r\n    }\r\n  }\r\n  changeWeight() {\r\n    const ans = !this.state.wall;\r\n\r\n    this.setState({ wall: ans });\r\n  }\r\n  chooseAlg(inputAlgo) {\r\n    this.setState({ selectedAlgo: inputAlgo });\r\n  }\r\n\r\n  render() {\r\n    const { grid } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <Home text={this.state.homeProp} callback7={() => this.noChange()} />\r\n        <Buttons\r\n          callback1={() => this.visualizeAlgorithm()}\r\n          callback2={() => this.changeWeight()}\r\n          callback3={() => this.clearpath()}\r\n          callback4={() => this.changediagonal()}\r\n          callback5={(oo) => this.chooseAlg(oo)}\r\n          brick={this.state.wall}\r\n          value={\r\n            this.state.diagonalMovement === true\r\n              ? \"Restrict Diagonal Movement\"\r\n              : \"Allow Diagonal Movement\"\r\n          }\r\n        />\r\n        <Statistics\r\n          text={this.state.selectedAlgo}\r\n          pathLength={this.state.path.length}\r\n          shortLength={this.state.short.length}\r\n          time={this.state.visualizationTime}\r\n        />\r\n\r\n        <div className=\"grid\" onMouseLeave={() => this.removeMouseDown()}>\r\n          {grid.map((row, rowIndex) => {\r\n            return (\r\n              <div key={rowIndex} className=\"row\">\r\n                {row.map((node, nodeIndex) => {\r\n                  const { row, col, isEnd, isStart, isWall, weight } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIndex}\r\n                      col={col}\r\n                      isEnd={isEnd}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      weight={weight}\r\n                      onMouseDown={(row, col) =>\r\n                        this.mouseDownHandler(row, col)\r\n                      }\r\n                      onMouseEnter={(row, col) =>\r\n                        this.mouseEnterHandler(row, col)\r\n                      }\r\n                      onMouseUp={() => this.mouseUpHandler()}\r\n                      row={row}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n        <Info />\r\n      </>\r\n    );\r\n  }\r\n}\r\nconst initialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 20; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 40; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === startRow && col === startCol,\r\n    isEnd: row === endRow && col === endCol,\r\n    weight: 0,\r\n    distance: Infinity,\r\n    f: 0,\r\n    g: 0,\r\n    h: 0,\r\n    isVisited: false,\r\n    isWall: false,\r\n    parent: null,\r\n    closed: false,\r\n  };\r\n};\r\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}